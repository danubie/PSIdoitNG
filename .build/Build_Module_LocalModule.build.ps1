task Build_Module_LocalModule {
    . Set-SamplerTaskVariable       # variables for current build
    if (-Not (Test-Path $BuiltModuleManifest -ErrorAction SilentlyContinue))
    {
        throw "Built module manifest not found (run task Build_Module_ModuleBuilder before): $BuiltModuleManifest"
    }
    # set $BuildRoot, ModuleManifestPath, BuiltModuleManifest(->Path string), ModuleInfo, OutputDirectory, ModuleVersion, ProjectName, ModuleVersionFolder  ...
    $moduleName = (Get-Item -Path $BuiltModuleManifest).BaseName

    # let the content of the psm1 point to the source files
    $psmContent = @'
    <#
    This file is generated by Invoke-Build. Do not edit it manually.
    It serves as a small wrapper to include all files from the source folder at startup of the module.
    #>
    $sourceDirectory = Get-ChildItem -Path '{0}' -Recurse -Filter '*.ps1'
    $ps1FileList = Get-ChildItem -Path $sourceDirectory -Recurse -Filter '*.ps1'
    $enums = $ps1FileList | Where-Object {{ $_.Directory.Name -eq "Enum" }}
    $classes = $ps1FileList | Where-Object {{ $_.Directory.Name -eq "Classes" }}
    $private = $ps1FileList | Where-Object {{ $_.Directory.Name -eq "Private" }}
    $public  = $ps1FileList | Where-Object {{ $_.Directory.Name -eq "Public"  }}
    foreach ($function in $classes) {{
        . $function.FullName
        Write-Verbose "Classes: $($function.FullName)"
    }}
    foreach ($function in $private) {{
        . $function.FullName
        Write-Verbose "private: $($function.FullName)"
    }}
    foreach ($function in $public) {{
        . $function.FullName
        Write-Verbose "public: $($function.FullName)"
    }}

    Write-Verbose "Exporting $($public.BaseName)"
    Export-ModuleMember -Function $public.BaseName
'@

    $psmContent -f $SourcePath | Out-File -FilePath (Join-Path -Path $BuiltModuleBase -ChildPath "$moduleName.psm1") -Force
}